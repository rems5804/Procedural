<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# Procedural Generation (Vue rapide)&#10;&#10;Petit récap des méthodes de génération dispo dans le projet. Objectif: aller droit au but pour retrouver l’essentiel sans roman.&#10;&#10;## Structure de base&#10;- `ProceduralGridGenerator` : composant qui crée la grille puis lance la méthode. Paramètres: Seed, StepDelay (ms), Debug.&#10;- `ProceduralGenerationMethod` : ScriptableObject abstrait. Fournit `Generate()` + annulation via `CancellationToken`. Accès simplifié à la grille et aux noms de tuiles (ROOM_TILE_NAME, CORRIDOR_TILE_NAME, etc.).&#10;- Pipeline: `Initialize(generator, randomService)` puis `Generate()` qui appelle votre `ApplyGeneration(token)`.&#10;&#10;Extrait simplifié:&#10;```csharp&#10;public async UniTask Generate() {&#10;    _cancellationTokenSource?.Cancel();&#10;    await UniTask.Delay(GridGenerator.StepDelay + 100);&#10;    _cancellationTokenSource = new CancellationTokenSource();&#10;    await UniTask.SwitchToMainThread();&#10;    await ApplyGeneration(_cancellationTokenSource.Token);&#10;}&#10;```&#10;&#10;## 1. Simple Room Placement&#10;Place un certain nombre de salles rectangulaires aléatoires sans chevauchement (petit buffer) puis relie chaque salle à la suivante par un couloir en &quot;L&quot;.&#10;- Paramètres principaux: MaxRooms, RoomMinSize, RoomMaxSize.&#10;- Vérifie la place avec `CanPlaceRoom(room, 1)`.&#10;- Couloirs: orientation aléatoire (horizontal d’abord ou vertical d’abord).&#10;&#10;Boucle de placement:&#10;```csharp&#10;for (int i = 0; i &lt; _maxSteps &amp;&amp; roomsPlacedCount &lt; _maxRooms; i++) {&#10;    int w = RandomService.Range(_roomMinSize.x, _roomMaxSize.x + 1);&#10;    int h = RandomService.Range(_roomMinSize.y, _roomMaxSize.y + 1);&#10;    int x = RandomService.Range(0, Grid.Width - w);&#10;    int y = RandomService.Range(0, Grid.Lenght - h);&#10;    var room = new RectInt(x, y, w, h);&#10;    if (!CanPlaceRoom(room, 1)) continue;&#10;    PlaceRoom(room);&#10;    roomsPlacedCount++;&#10;    await UniTask.Delay(GridGenerator.StepDelay, cancellationToken: token);&#10;}&#10;```&#10;Couloir en L:&#10;```csharp&#10;void CreateDogLegCorridor(Vector2Int a, Vector2Int b) {&#10;    if (RandomService.Chance(0.5f)) { // horizontal puis vertical&#10;        CreateHorizontalCorridor(a.x, b.x, a.y);&#10;        CreateVerticalCorridor(a.y, b.y, b.x);&#10;    } else { // vertical puis horizontal&#10;        CreateVerticalCorridor(a.y, b.y, a.x);&#10;        CreateHorizontalCorridor(a.x, b.x, b.y);&#10;    }&#10;}&#10;```&#10;&#10;## 2. Cellular Automata&#10;Automate binaire sur la grille (terre / eau). Remplissage initial pseudo-aléatoire selon un pourcentage puis plusieurs itérations de &quot;lissage&quot; basées sur le nombre de voisins.&#10;- Paramètres: randomFillPercent, iterations, groundThreshold.&#10;- Stocke trois matrices: `_grid` (courant), `_buffer` (prochain état), `_applied` (ce qui a déjà été instancié).&#10;- Optimise: applique uniquement les cellules qui changent.&#10;&#10;Étape de transition:&#10;```csharp&#10;for (int y = 0; y &lt; h; y++) {&#10;  for (int x = 0; x &lt; w; x++) {&#10;    int neigh = CountGroundNeighbors(x,y,w,h);&#10;    _buffer[x,y] = neigh &gt;= groundThreshold;&#10;  }&#10;}&#10;// swap&#10;var tmp = _grid; _grid = _buffer; _buffer = tmp;&#10;```&#10;Comptage des voisins (8 directions):&#10;```csharp&#10;int CountGroundNeighbors(int x,int y,int w,int h){&#10;  int c=0; for(int dy=-1;dy&lt;=1;dy++){int ny=y+dy; if(ny&lt;0||ny&gt;=h)continue;&#10;    for(int dx=-1;dx&lt;=1;dx++){ if(dx==0&amp;&amp;dy==0)continue; int nx=x+dx; if(nx&lt;0||nx&gt;=w)continue; if(_grid[nx,ny]) c++; }&#10;  } return c;&#10;}&#10;```&#10;&#10;## 3. BSP (BSP2)&#10;Division récursive de la zone en sous-rectangles (noeuds). Chaque feuille pose une salle. Les feuilles sœurs sont reliées par couloirs.&#10;- Paramètres: HorizontalSplitChance, SplitRatio(min/max), MaxSplitAttempt, LeafMinSize, RoomMin/MaxSize.&#10;- Tente plusieurs ratios avant d’abandonner (feuille).&#10;- Salle finale: taille réajustée aléatoirement dans les limites, puis marquage des cellules.&#10;&#10;Logique de split:&#10;```csharp&#10;for (int i = 0; i &lt; MaxSplitAttempt; i++) {&#10;    bool horizontal = _randomService.Chance(HorizontalSplitChance);&#10;    float ratio = _randomService.Range(SplitRatio.x, SplitRatio.y);&#10;    if (horizontal ? CanSplitHorizontally(ratio, out a, out b)&#10;                   : CanSplitVertically(ratio, out a, out b)) { splitFound = true; break; }&#10;}&#10;if (!splitFound) { // feuille&#10;    PlaceRoom(_room); return; }&#10;_child1 = new Node(... a); _child2 = new Node(... b);&#10;```&#10;Connexion des feuilles (centres des derniers descendants):&#10;```csharp&#10;var c1 = node1.GetLastChild()._room.GetCenter();&#10;var c2 = node2.GetLastChild()._room.GetCenter();&#10;CreateDogLegCorridor(c1, c2);&#10;```&#10;&#10;## Tiles / Objets&#10;Nom des templates utilisés (DB ScriptableObject):&#10;- Room&#10;- Corridor&#10;- Grass / Water (cellular)&#10;&#10;Ajouter un objet: `AddTileToCell(cell, ROOM_TILE_NAME, true);`&#10;&#10;## Utilisation rapide&#10;1. Ajouter le composant `ProceduralGridGenerator` sur un GameObject.&#10;2. Assigner une méthode (un ScriptableObject créé via CreateAssetMenu).&#10;3. Régler Seed, StepDelay, Dimensions de la grille (dans le générateur de base).&#10;4. Lancer la génération (Play ou bouton custom si présent).&#10;&#10;## Annulation / Pas à pas&#10;- Chaque méthode peut être annulée (nouvelle génération relance un token). &#10;- `StepDelay` ralentit visuellement les étapes (utile pour debug ou vidéo).&#10;&#10;## Idées d’extension&#10;- Post-process pour lisser les couloirs.&#10;- Placement d’items aléatoires sur cases &quot;Room&quot; uniquement.&#10;- Génération de portes entre couloir et salle.&#10;&#10;Fin. README volontairement court et direct.&#10;" />
              <option name="updatedContent" value="# Procedural Generation (Vue rapide)&#10;&#10;Petit récap des méthodes de génération dispo dans le projet. Objectif: aller droit au but pour retrouver l’essentiel sans roman.&#10;&#10;## Structure de base&#10;- `ProceduralGridGenerator` : composant qui crée la grille puis lance la méthode. Paramètres: Seed, StepDelay (ms), Debug.&#10;- `ProceduralGenerationMethod` : ScriptableObject abstrait. Fournit `Generate()` + annulation via `CancellationToken`. Accès simplifié à la grille et aux noms de tuiles (ROOM_TILE_NAME, CORRIDOR_TILE_NAME, etc.).&#10;- Pipeline: `Initialize(generator, randomService)` puis `Generate()` qui appelle votre `ApplyGeneration(token)`.&#10;&#10;Extrait simplifié:&#10;```csharp&#10;public async UniTask Generate() {&#10;    _cancellationTokenSource?.Cancel();&#10;    await UniTask.Delay(GridGenerator.StepDelay + 100);&#10;    _cancellationTokenSource = new CancellationTokenSource();&#10;    await UniTask.SwitchToMainThread();&#10;    await ApplyGeneration(_cancellationTokenSource.Token);&#10;}&#10;```&#10;&#10;## 1. Simple Room Placement&#10;Place un certain nombre de salles rectangulaires aléatoires sans chevauchement (petit buffer) puis relie chaque salle à la suivante par un couloir en &quot;L&quot;.&#10;- Paramètres principaux: MaxRooms, RoomMinSize, RoomMaxSize.&#10;- Vérifie la place avec `CanPlaceRoom(room, 1)`.&#10;- Couloirs: orientation aléatoire (horizontal d’abord ou vertical d’abord).&#10;&#10;Boucle de placement:&#10;```csharp&#10;for (int i = 0; i &lt; _maxSteps &amp;&amp; roomsPlacedCount &lt; _maxRooms; i++) {&#10;    int w = RandomService.Range(_roomMinSize.x, _roomMaxSize.x + 1);&#10;    int h = RandomService.Range(_roomMinSize.y, _roomMaxSize.y + 1);&#10;    int x = RandomService.Range(0, Grid.Width - w);&#10;    int y = RandomService.Range(0, Grid.Lenght - h);&#10;    var room = new RectInt(x, y, w, h);&#10;    if (!CanPlaceRoom(room, 1)) continue;&#10;    PlaceRoom(room);&#10;    roomsPlacedCount++;&#10;    await UniTask.Delay(GridGenerator.StepDelay, cancellationToken: token);&#10;}&#10;```&#10;Couloir en L:&#10;```csharp&#10;void CreateDogLegCorridor(Vector2Int a, Vector2Int b) {&#10;    if (RandomService.Chance(0.5f)) { // horizontal puis vertical&#10;        CreateHorizontalCorridor(a.x, b.x, a.y);&#10;        CreateVerticalCorridor(a.y, b.y, b.x);&#10;    } else { // vertical puis horizontal&#10;        CreateVerticalCorridor(a.y, b.y, a.x);&#10;        CreateHorizontalCorridor(a.x, b.x, b.y);&#10;    }&#10;}&#10;```&#10;&#10;## 2. Cellular Automata&#10;Automate binaire sur la grille (terre / eau). Remplissage initial pseudo-aléatoire selon un pourcentage puis plusieurs itérations de &quot;lissage&quot; basées sur le nombre de voisins.&#10;- Paramètres: randomFillPercent, iterations, groundThreshold.&#10;- Stocke trois matrices: `_grid` (courant), `_buffer` (prochain état), `_applied` (ce qui a déjà été instancié).&#10;- Optimise: applique uniquement les cellules qui changent.&#10;&#10;Étape de transition:&#10;```csharp&#10;for (int y = 0; y &lt; h; y++) {&#10;  for (int x = 0; x &lt; w; x++) {&#10;    int neigh = CountGroundNeighbors(x,y,w,h);&#10;    _buffer[x,y] = neigh &gt;= groundThreshold;&#10;  }&#10;}&#10;// swap&#10;var tmp = _grid; _grid = _buffer; _buffer = tmp;&#10;```&#10;Comptage des voisins (8 directions):&#10;```csharp&#10;int CountGroundNeighbors(int x,int y,int w,int h){&#10;  int c=0; for(int dy=-1;dy&lt;=1;dy++){int ny=y+dy; if(ny&lt;0||ny&gt;=h)continue;&#10;    for(int dx=-1;dx&lt;=1;dx++){ if(dx==0&amp;&amp;dy==0)continue; int nx=x+dx; if(nx&lt;0||nx&gt;=w)continue; if(_grid[nx,ny]) c++; }&#10;  } return c;&#10;}&#10;```&#10;&#10;## 3. BSP (BSP2)&#10;Division récursive de la zone en sous-rectangles (noeuds). Chaque feuille pose une salle. Les feuilles sœurs sont reliées par couloirs.&#10;- Paramètres: HorizontalSplitChance, SplitRatio(min/max), MaxSplitAttempt, LeafMinSize, RoomMin/MaxSize.&#10;- Tente plusieurs ratios avant d’abandonner (feuille).&#10;- Salle finale: taille réajustée aléatoirement dans les limites, puis marquage des cellules.&#10;&#10;Logique de split:&#10;```csharp&#10;for (int i = 0; i &lt; MaxSplitAttempt; i++) {&#10;    bool horizontal = _randomService.Chance(HorizontalSplitChance);&#10;    float ratio = _randomService.Range(SplitRatio.x, SplitRatio.y);&#10;    if (horizontal ? CanSplitHorizontally(ratio, out a, out b)&#10;                   : CanSplitVertically(ratio, out a, out b)) { splitFound = true; break; }&#10;}&#10;if (!splitFound) { // feuille&#10;    PlaceRoom(_room); return; }&#10;_child1 = new Node(... a); _child2 = new Node(... b);&#10;```&#10;Connexion des feuilles (centres des derniers descendants):&#10;```csharp&#10;var c1 = node1.GetLastChild()._room.GetCenter();&#10;var c2 = node2.GetLastChild()._room.GetCenter();&#10;CreateDogLegCorridor(c1, c2);&#10;```&#10;&#10;## Tiles / Objets&#10;Nom des templates utilisés (DB ScriptableObject):&#10;- Room&#10;- Corridor&#10;- Grass / Water (cellular)&#10;&#10;Ajouter un objet: `AddTileToCell(cell, ROOM_TILE_NAME, true);`&#10;&#10;## Utilisation rapide&#10;1. Ajouter le composant `ProceduralGridGenerator` sur un GameObject.&#10;2. Assigner une méthode (un ScriptableObject créé via CreateAssetMenu).&#10;3. Régler Seed, StepDelay, Dimensions de la grille (dans le générateur de base).&#10;4. Lancer la génération (Play ou bouton custom si présent).&#10;&#10;## Annulation / Pas à pas&#10;- Chaque méthode peut être annulée (nouvelle génération relance un token). &#10;- `StepDelay` ralentit visuellement les étapes (utile pour debug ou vidéo).&#10;&#10;## Idées d’extension&#10;- Post-process pour lisser les couloirs.&#10;- Placement d’items aléatoires sur cases &quot;Room&quot; uniquement.&#10;- Génération de portes entre couloir et salle.&#10;&#10;Fin. README volontairement court et direct.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>